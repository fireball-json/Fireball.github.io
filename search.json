[{"title":"移动端开发遇到的问题","url":"/2024/07/20/移动端开发遇到的问题/","content":" - [安卓保存图片乱序](#title_1)\n - [IOS切换应用音频失效](#title_2)\n\n<!-- more -->\n\n## <span id=\"title_1\" />1.安卓保存图片乱序\n### 问题描述\n在之前的安卓开发中，用户反馈软件软件保存的顺序混乱(这里需要提一下，软件保存图片是在**同一时间保存多张、有顺序的图片**)。\n### 解决方案\n经过最初的复现，发现图片的名称命名为：xxx_1，会产生：xxx_1，xxx_11，...，xxx_2 这样的顺序。\n修改名称到新的格式：xxx_001，在手机上保存十几张图片，发现顺序恢复正常，遂进行其它的工作。\n\n但是还是偶尔有用户反馈顺序混乱，问题并没有解决。经过详细的检查，发现有以下问题：\n1. IOS系统和桌面端，顺序是正常的；\n2. 安卓手机中，图库的顺序都有问题；\n3. 安卓手机中，保存图片的文件夹中，华为的顺序是正常的，其它的混乱；\n4. 单次保存的图片量需要比较大才会出现问题；\n\n由于以上的原因，所以这个问题偶尔才只是偶尔出现。查询图片的属性，发现在android系统中，图片默认排序是**修改时间**排序；所以在原生端中使用File的`setLastModified`修改图片**修改时间**属性。依次增加**1ms**之后却没有解决问题，查询相关信息得知，**android最小间隔时间是1秒**，所以最终解决方案只是在保存函数运行的时候，为每一张图片的**修改时间**依次增加一秒。这样或许会引发其它的问题，所以这只是一个暂时的解决方案。\n\n## <span id=\"title_2\" />2.IOS切换应用音频失效\n### 问题描述\n在IOS的开发中，遇到一个问题，当app在后台切换之后，再次进入，音频播放会直接失效，safari查看控制台，未见报错。\n### 问题分析\n查看代码发现，在项目中，并不是直接创建的`<audio>`标签进行音频播放，而是使用了`AudioContext`的实例，调用`decodeAudioData`读取buffer的信息，查阅MDN文档获取了以下信息(尽量查阅英文版本的MDN文档)：\n##### 1.AudioContext对象\n`AudioContext`是一个有音频模块链接成的处理图，每一个模块都是一个`AudioNode`模块，我们只需要创建一个`AudioContext`对象，即可在上下文中处理所有事情。\n##### 2.实例方法\n`AudioContext`上挂载了多个实例方法，常用的：\n1. **close**：关闭节点，但是在其它引用解除之前是不会释放对象的，只是会暂停音频进程和暂停音频处理；\n2. **suspend**：暂停音频上下文进度，暂时剥离对音频硬件访问。可以减少对cpu和电池的使用。\n3. **resume**：恢复被暂停的音频。\n##### 3.音频状态\n音频状态有三个：**closed**，**suspend**，**running**。\n对应了上述实例方法调用之后的状态，调用`close`之后，state转为**closed**状态；同样的，调用`suspend`后，状态转为**suspended**状态； 当正常播放时，则为**running**状态。\n### 问题确认\n现在回到问题，为什么只在ios发生了这个问题呢，需要再测试一下：\n打开代码发现，切换后台这个动作在app内部没有做任何动作，即音频还是在后台继续播放；使用真机测试后发现，android切换到后台，app音频仍在播放，切换回去之后，**AudioContext.state**的状态是**running**，那ios呢，切换后台之后，音频在播放，**AudioContext.currentTime**是在正常流动的，可是没有声音，同时切换回app之后，**AudioContext.state**是**interrupted**状态...\n正在疑惑的时候，我突然想到查阅mdn文档经常遇到的问题，果断切换到英文之后，找到了原因：\n\n![MDN DOCS in English](../img/blog/mobile_1.png)\n\n### 解决方案\n查阅文档之后，在不影响原来的逻辑的情况下，在代码中补充了两个操作：\n    1. 判断ios环境，在切换到后台之后，暂停播放；\n    2. 判断ios环境，在播放操作触发时，判断状态是否是**interrupted**，若是，则调用`resume`方法。","tags":["Android IOS"]},{"title":"Web开发遇到的问题：Resize操作","url":"/2024/07/20/Web开发遇到的问题/","content":" - [Resize Obeserver](#title_1)\n - [clientHeight & getBoundingClientRect](#title_2)\n\n\n## <span id=\"title_1\" />1.Resize Observer报错\n### 发现问题\n在一个多层嵌套的组件中，控制台总是会报错一个error: `ResizeObserver loop completed with undelivered notifications.`，但是不影响整个项目的运行。\n\n![console error](../img/blog/web_1.png)\n\n在google搜索，指向英文的MDN文档，有具体的解释（所以一定切英文MDN文档查资料）。正常的resize事件应当在绘制前调用，当resize事件触发后，样式重新进行评估，可会导致更多的resize事件触发。而回到这次遇到问题的组件中，我发现，当上层组件调整大小后，底层组件通过ResizeObserver回调，来实现自身自适应的大小变换，这个计算量比较大，而这个过程并没有限制在绘制前还是绘制后执行。\n\n### 初步解决\n检查改变元素大小的相关代码，发现是使用拖动改变元素的，最开始觉得是同一时间触发的事件太多了，而每次计算时间又不那么短，所以导致每次调用函数时没有执行完成导致的，在原基础上使用的setTimeout进行制约，发现没有报错了，但是拖动放大的动画不是很舒服，后续改用requestAnimationFrame之后，体验增加了。\n\n##### requestAnimationFrame\n这是一个挂载在window对象下的方法，这是一个类似于setInterval的api\n``` Javascript\nrequestAnimationFrame(callback)\nfunction callback(timestamp) {\n  // timestamp是每一次调用函数的开始时间\n}\n```\n与setInterval不同的是，它不是依照时间进行回调的，而是依赖于屏幕刷新率。当浏览器准备渲染下一帧时，则会调用callback回调函数。这个回调函数有一个参数，是该回调函数执行时的开始时间。使用这个api进行动画的渲染，会非常的流畅，但是因为执行是基于刷新率，在高刷新率时，动画执行速度会快一些，这时可以用callback函数的timestamp参数进行动画的计算。需要注意的是**回调函数总是在下一帧渲染时调用，所以这个时间并不是当前帧的时间，此外下一帧调用也意味着这是一个异步执行的函数**\n\n### 总结\n对于**ResizeObserver loop completed with undelivered notifications.**这个问题，本质上是`ResizeObserver回调函数`执行的中在同一次绘制引发了自身大小改变导致的，按照MDN的解释，是循环依赖导致的无限循环只会在每次迭代期间处理DOM中更深的元素的方式解决，并且推送这个error信息。在不对项目回调函数进行大修改之前，为了优化这个问题，使用**requestAnimationFrame**代替**setTimeout**便可以解决这个问题。 \n\n## <span id=\"title_2\" />2.clientHeight & getBoundingClientRect\n有resize操作的组件本质上用于截屏，需要同时获取元素的位置以及宽高，由于使用了**transform: scale**，所以使用了el.getBoundingClientRect获取元素当前大小和位置。\n当截图开始后会使用eelctron新开一个窗口进行操作，使用getBoundingClientRect获取的高度数据，在高度上分割图片成多个小图截图以保证清晰度，但是在最终拼接时总是出现对不上的问题。查询api后发现问题：\n#### 问题复现\n##### 1.getBoundingClientRect\n这个api获取的是一个**DOMRect**对象，拥有多个属性：水平垂直坐标x/y，矩形宽高width/height，矩形上右下左坐标top/right等，此外，如果是一个不规则图形例如圆形，仍然获得对应最小的矩形的属性（ps.如果需要文字环绕圆形可以使用**shape-outside**这个css属性）。**DOMRect**对象的各个属性根据实际显示的效果，即**scale**会影响最终的数据，并且这个属性是有小数的。\n##### 2.offsetHeight/offsetWidth & clientHeight/clientWidth\n这两个属性可以获取元素的实际大小，是**scale**不生效的时候的大小，或者说是**scale**为1时候的大小。\noffsetHeight/offsetWidth，获取了边框内边距以及**滚动条**的宽高，是标志一个元素实际占用页面空间；clientHeight/clientWidth只包含了内边距，是元素内容宽高或者叫可见宽高，他们获取的属性返回值通常是整数。\n\n#### 总结\n由于计算切割位置使用的带小数的数据，但实际截图拼接时没有，导致了操作界面的图片比例和截图窗口的图片比例不同，虽然差距仅有几个px，但是在拼接图片的操作中影响很大。\n","tags":["ResizeObserver"]},{"title":"Typescript Study Notes","url":"/2024/02/20/Typescript Study Notes/","content":"## Catalouge\n  - [Preface](#preface)\n  - [Union type and Intersection type](#utait)\n    - [Keyof Union type](#utait_1)\n    - [Satisfies](#utait_2)\n    - [Ergodic union type](#utait_3)\n  - [Conditional types](#ct)\n    - [Keyword `infer`](#ct_1)\n    - [Compare diffirent types](#ct_2)\n    - [Distribute union types](#ct_3)\n<!-- more -->\n\n\n## <span id=\"preface\" />Preface\nI have used Typescript in development for about one and half year, but a systematic learning is never happened during my front-end work. Luckly, I got a period time between my last job and my next job, so it's time to make deep study of Typescript🎉!\n\n## <span id=\"utait\" />Union type and Intersection type\n#### <span id=\"utait_1\" />1. Keyof union type\nUnion type is a way to combine types, formed from two or more other types. So what about the keys of a union type?\n``` Typescript\ntype UnionInterface = { name: string } | { name: string; age: number; sex: number }\n\nconst people1: UnionInterface = { name: 'JACK' } // √\nconst people2: UnionInterface = { name: 'JACK', age: 23 } // √\nconst people3: UnionInterface = { age: 23 } // ×\n```\nThe example above confused me a lot at first. But an explain from `The Typescript Handbook` may help us understand the loogic of it.\n> Only the intersection of those facts applies to the union of the sets themselves. For example, if we had a room of tall people wearing hats, and another room of Spanish speakers wearing hats, after combining those rooms, the only thing we know about every person is that they must be wearing a hat.\n\nThe key **`name`** can be interpreted as `a safety key` which means every member of the union type **`UnionInterface`** must have it. Then a conclusion come naturally that `keyof`**`UnionInterface`** expected to be **`name`**, or a union type seems has some properties of an intersection type.\n\n#### <span id=\"utait_2\" />2. Satisfies\nProviding a value matching a union type is pretty easy: just provide a type that matching any memebers of the union type. However, somtimes we want to restrict the type of the value without rewrite a union type. `Typescript 4.9` give a keyword named **`satisfies`**.\n``` Typescript\ntype SatisfiesType = {\n  name: string\n  hobby: 'soccer' | 'tennis' | 'swimming' | 'running'\n}\n\nconst Jack: SatisfiesType = {\n  name: 'Jack',\n  hobby: 'soccer' | 'tennis',\n}\n\nconst Mary = {\n  name: 'Mary',\n  hobby: 'swimming' | 'running',\n} satisfies SatisfiesType\n\n// do some reassignment\nJack.hobby = 'swimming' // √\nMary.hobby = 'tennis' // ×\n```\nThis keyword `satisfies` can make prediction of the type with an instance. It provide type declaration and type infers at the same time🎉! But is there any way that can restrict the range of type without an instance. Or in other words, I need a type which can predict other types according to the attribute that entered by myself.\n\n#### <span id=\"utait_3\" />3. Ergodic union type\nIn the section above, there is still a problem of how to predict other attributes' types according to the attribute that entered by myself. For example\n``` Typescript\ntype Hobbies = {\n  Jack: 'tennis' | 'soccer'\n  Mary: 'running' | 'swimming'\n}\n\nconst person: /** some type */ = {\n  name: 'Jack'\n  hobbies: // expected to be 'tennis' | 'soccer'\n}\n```\nIt easy to make it when we declare a union type: \n``` Typescript\ntype Person = {\n  name: 'Jack'\n  hobby: 'tennis' | 'soccer'\n} | {\n  name: 'Mary'\n  hobby: 'running' | 'swimming'\n}\n```\nThis method can work when there is not many members of the union type, and it seems so unpleasant when we have to maitain the type. Therefore we need a more generic method to declare the union type, and a tenary expression: `T extends T ?` may help us a lot.\n``` Typescript\ntype Person<T extends keyof Hobbies = keyof Hobbies> = T extends T\n  ? {\n      name: T\n      hobby: Hobbies[T]\n    }\n  : never\n\nconst person: Person = {\n  name: 'Jack',\n  hobby: // ('tennis' | 'soccer') is inferred\n}\n```\nWith type similar to `Person`, it will be super easy for us to get an expect value when we do some coding.\n![Auto predict🎉🎉🎉](../img/blog/typescript_1.png)\n\n## <span id=\"ct\" />Conditional types\nConditional types are used to describe the relation between the types of inputs and outputs. As I mentioned above, I used `T extends T ? ` to destribute a union type. In fact this kind of expression which is like a tenary expression has a name `Conditional Types`\n\n#### <span id=\"ct_1\" />Keyword `infer`\nThe keyword `infer` is an amazing design. As it's name shows, `infer` is used to \"infer\" a type from another type.\n``` Typescript\ntype InferExample = { name: string; age: number } extends { name: infer A } ? A : never // string\n```\nIn my opinion, `infer` is just like `x` in equtions. People can use this keyword to do many operations.\n``` Typescript\ntype SliceStr<T extends string> = 'Typescript is great' extends `${infer A} is${string}` ? A : never // Tpescript \ntype DivideArray<T extends any[]> = ['a', 'b', 'c'] extends [infer A, ...infer Rest] ? A : never // 'a'\n\n// and it is valid for functions\ntype ReturnFunction<T extends (...args: any) => any> = T extends (...args: any[]) => infer U ? U : any\nconst testFn = (a: number) => a\ntype ReturnTest = ReturnFunction<typeof testFn> // number\n``` \n\n#### <span id=\"ct_2\" />Compare diffirent types\nIn `conditional types`, the type on the left of the **extends** can assignable to the one on the right will decide the type you get comes from the first branch or the second one. But there is some peorblem I met when I compared two types in conditional types.\n\ntype `never` is assignable to everything. And nothing is assignable to `never`. When some type you decalre is wrong and it will return type `never`\n``` Typescript\ntype GetNever = string & number // never\n```\ntype `unknown` is similar to the type `any`, but when we use `unknown` means that ther definitelty be a type except `never`. Therefore use `unknown` instead of `any` could be better when we migrate from `Javascript` to `Typescript`.Except afore-mentioned examples, the specific relationships between abstract types.\n![Abstract types relationships](../img/blog/typescript_2.png)\n\n#### <span id=\"ct_3\" />Distribute union types\nIn the previous article, I used conditional type `T extends T ?` to distribute union types. In fact, sometime we do not need distributing union types, and `[]` will help us avoid this behavior.\n``` Typescript\ntype UnionType = string | number\n\ntype UnionToArray<T> = T extends unknown ? T[] : never\ntype UnknownArray = UnionToArray<UnionType> // expect string[] | number[]\n\n// with \"[]\"\ntype UnionToArray<T> = [T] extends [unknown] ? T[] : never\ntype UnknownArray = UnionToArray<UnionType> // expect (string | number)[]\n```\n### To be continue ... ...","tags":["Typescript"]},{"title":"NuxtJs-2.x Memory Leak","url":"/2024/01/20/NuxtJs Memory Leak/","content":" - [Problem](#Problem)\n - [Memory Leak ](#Memory)\n - [Solution](#Solution)\n - [Conclusion](#Conclusion)\n - [Reference](#Reference)\n\n<!-- more -->\n\n## <span id=\"Problem\" />Problem\nDuring my previous job, I met a problem where the server memory useage is always increase very quickly, and it will reboot automatically when memory useage reached a threshold. At first, we speculated that meybe it is due to the high visit volume during peak time, and the solution is ...emmm ADD MORE SERVER! (┓( ´∀` )┏)\nAnd it's easy to predict what will happen next: our website will run slower and slower. At last, we decide to check whether we encountered memory leak.\n\n## <span id=\"Memory\" />Memory Leak \nFirst of all, I have to figure it out if the memory leak has really happpened. Our production is a server side render website which we used NuxtJs-2.X to make it. So as the memory leak occurs on the server side, we can't simply use the **`Memory`** tool from Chrome Dev-Tools to take a snapshot of the heap size. Fortunately I discovered a solution from other developer's articles.\n### 1. How to take server side memory snapshot \nThere is a tool that chrome give to us to inspect the devices. Just type **`chrome://inspect/#devices`** into the address bar of chrome broswer, and then you will see something like this:\n\n![chrome://inspect/#devices](../img/blog/memory_leak_1.png)\nSet your server side local address in **`Configure`** of **` Discover network targets`**, and then it will work when the service of server-side is running.\n#### 2. Set inspect port before build\nAfter kowning how to inpect server-side memory useage, there is another problem with how to run our server on a specific port. And Node give us a solution which named `v8 Inspector Protocol`. Add the following code to `package.json`, and run it.\n\n``` bash\n$ \"inspect:start\": \"node --inspect=9001 node_modules/nuxt/bin/nuxt start --modern=server\"\n```\n\n#### 3. Take server-side heap snapshots\nBefore excuting this command, you need build your project first. When the project is running normally, visit `chrome://inspect/#devices`, and choose the `Memory` panel. Take heap snapshots twice and compare them.\n\n![memory snapshot comparation](../img/blog/memory_leak_2.png)\n\nIf you need send lot of concurrent requests when take heap snapshot, try [loadtest](https://github.com/alexfernandez/loadtest), it helps me a lot.\n\n## <span id=\"Solution\" />Solution\nAfter check more code, I found an `eventbus` that may be the ultimate reason.\n\n``` bash\ncreated () {\n  eventHub.$on(EventName, () => {\n    this.loading = true \"//this is use in a component which we regist with vue.component\"\n  })\n},\n```\n\nThough we use `$off` to cancel it in the hook `unmounted`, but but according to the reference of nuxtjs, there are only two lifecycle hooks be called both, from client-side and server-side: `beforeCreate` and `created`. \n\n``` bash\ncreated () {\n  if(process.env === 'client'){ \"//add a enviroment judgement\" \n    eventHub.$on(EventName, () => {\n      this.loading = true \n    })\n  }\n},\n```\nAfter add a judgement about enviroment, I took another two snapshot and the problem seems be solved.\n\n## <span id=\"Conclusion\" />Conclusion\nThe content above describes the process of how I identify the server-side memory leak problem and solve it. In fact, during the time when I was looking for information in the Nuxtjs document, I found that `vue.use` and `vue.component` may cause memory leak, but I'm not sure if it is related to this project. I can't go into this problem due to my dismissal from my last job, I tried to reproducing the issue with nuxtjs-3.x, but it didn't go as planned. Maybe next time when I meet something simillar, I will update this blog!😊\n\n## <span id=\"Reference\" />Reference\nhttps://medium.com/le-collectionist/solving-server-side-memory-leaks-on-nuxt-js-ecd6b16b54a0\nhttps://stackoverflow.com/questions/66831561/nuxt-add-global-plugins-memory-leakage-issue\nhttps://github.com/alexfernandez/loadtest","tags":["NuxtJs"]}]